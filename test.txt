In the last few projects I have implemented a Development environment for the microservices and android application using the Vagrant with Docker.

In those good days when the software was to be released every year and the developers will stay in the company for decades, there used to be tens of wiki pages describing how to set up your local machine for developing the greatest app on the earth.
There used to many more pages, describing how to push the changes to git/svn repo in order to make sure that the Continous Integration process does not fail overnight and your release manager does not yell at you.
But the yelling will never stop and you will find the pissed of colleagues telling you how inept you are. And you would be furstratingly thinking that everything passed on my local machine, maven, gradle, unit tests and even e2e acceptance test were passing.
Fast forward to 2010, with multiple git repos, separate projects for each microservice, 100's of CI pipeline (say one for each microservice), and the enthusiastic developers coding day and night pushing the changes to git repo triggering the CI and even CD process.
And now even though your CI process runs takes only minutes to run for each service, but there are 100's of concurrently executing process. Last thing you need is the scenario where developer checks in the code that keeps on failing on the CI server while being successful on his/her local machine.
Last but not the least, if the team consists of developers with local machines running windows, linux and the mac at the sametime, then you need to maintain the wiki pages for each environment set up and also deal with the situation where something is available on one platform and not on other.

In this context the Vagrant+Docker setup for local environment using the local Jenkins CI pipeline takes care of all of the above concerns. Let us say you join an awsome software development company and they give you brand new laptop and ask you to just intall vagrant and your preferred IDE.
Only thing you need to do is git checkout the code which contains there files apart from the code.
a) Vagrantfile
b) Dockerfile
c) Jenkinsfile

Only thing you need to do is "vagrant up" and here you go:
What you get:
1. A local instance of Jenkins which has exactly the same pipeline with relevant stages only.
2. All the necessary dev tools inside the docker container called dev-container, which could be managed by the team lead.
3. Local Docker host and docker-compose running inside the VM, with the local docker repo connectivity if needed.

The developer is up and running in just few minutes and even contributing to the code right away.




